<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stress Relief Simulator</title>
    <link rel="stylesheet" href="style.css"> <!-- Use the external stylesheet -->
    <link rel="icon" href="pictures/favicon.png" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <!-- Consistent header as in other pages -->
    <header>
        <h1>Jonathan Rothe</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="about.html">About Me</a></li>
                <li><a href="resume.html">My Resume</a></li>
                <li><a href="projects.html">Projects</a></li>
            </ul>
        </nav>
    </header>

    <main class="game-page">
        <h1>Stress Relief Simulator</h1>

        <!-- Explosion power control -->
        <div class="slider-container">
            <label for="explosion-power">Explosion Power:</label>
            <input type="range" id="explosion-power" min="50" max="500" value="200">
        </div>

        <!-- Game area placeholder -->
        <div id="game-container">
            <!-- Canvas will be dynamically sized -->
            <canvas id="game-canvas"></canvas>
        </div>

        <!-- Control buttons -->
        <div class="button-container">
            <button id="play-button">Play</button>
            <button id="reset-button">Reset</button>
        </div>
    </main>

    <footer>
        <p>Developed by Jonathan Rothe</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        const playButton = document.getElementById('play-button');
        const resetButton = document.getElementById('reset-button');
        const explosionPowerSlider = document.getElementById('explosion-power');
        let isPlaying = false;

        // Setup for Matter.js Game
        const { Engine, Render, Runner, Bodies, World, Events, Body, Vector, Composite, Composites } = Matter;

        // Create the engine and world outside initGame
        let engine = Engine.create();
        let world = engine.world;

        // Create render and runner outside initGame
        let renderOptions = {
            element: document.getElementById('game-container'),
            canvas: document.getElementById('game-canvas'),
            engine: engine,
            options: {
                wireframes: false,
                background: '#ccc',
                // We'll set width and height dynamically
            }
        };

        let render = Render.create(renderOptions);

        let runner = Runner.create();

        let ground;
        let wall;
        const minBlockSize = 5; // Reduced minimum size to allow blocks to fragment further

        function initGame() {
            // Clear the world
            World.clear(world);
            Engine.clear(engine);

            // Adjust canvas size
            resizeCanvas();

            // Ground
            const canvasWidth = render.canvas.width;
            const canvasHeight = render.canvas.height;
            ground = Bodies.rectangle(canvasWidth / 2, canvasHeight - 10, canvasWidth + 20, 20, { isStatic: true });

            // Create a wall of blocks
            const blockSize = 40;
            const columns = 10;
            const rows = 10;
            const totalBlockWidth = columns * blockSize;
            const totalBlockHeight = rows * blockSize;
            const startX = (canvasWidth - totalBlockWidth) / 2;
            const startY = canvasHeight - totalBlockHeight - 20; // Position blocks above the ground

            wall = Composites.stack(startX, startY, columns, rows, 0, 0, function(x, y) {
                const color = getRandomColor();
                const block = Bodies.rectangle(x, y, blockSize, blockSize, {
                    render: {
                        fillStyle: color
                    }
                });
                block.initialSize = blockSize; // Store the initial size
                block.blockColor = color; // Store the block's color for fragments
                return block;
            });

            World.add(world, [ground, wall]);

            // Remove blocks that go off-screen
            Events.on(engine, "afterUpdate", removeOffScreenBodies);

            // Render the initial scene
            Render.world(render);
        }

        function startGame() {
            Runner.start(runner, engine);
            Render.run(render);
            isPlaying = true;
            playButton.textContent = 'Pause';
        }

        function pauseGame() {
            Runner.stop(runner);
            Render.stop(render);
            isPlaying = false;
            playButton.textContent = 'Play';
        }

        function resetGame() {
            // Stop the runner and renderer
            Runner.stop(runner);
            Render.stop(render);

            // Re-initialize the game
            initGame();

            // Start the game if it was playing
            if (isPlaying) {
                startGame();
            }
        }

        function applyExplosion(point) {
            const explosionRadius = parseInt(explosionPowerSlider.value); // Use value from slider
            const forceMagnitude = explosionRadius / 4000; // Adjusted force based on explosion radius

            // Add explosion visual effect
            createExplosionEffect(point, explosionRadius);

            const bodies = Composite.allBodies(world);

            bodies.forEach(body => {
                if (body.isStatic) return;

                const distanceVector = Vector.sub(body.position, point);
                const distance = Vector.magnitude(distanceVector);

                // Apply force if the body is within the explosion radius
                if (distance < explosionRadius) {
                    const forceDirection = Vector.normalise(distanceVector);
                    const force = Vector.mult(
                        forceDirection,
                        forceMagnitude * (1 - distance / explosionRadius)
                    );

                    Body.applyForce(body, body.position, force);

                    // Fragment the block into three smaller blocks if it's close enough
                    if (distance < explosionRadius / 2) {
                        fragmentBody(body);
                    }
                }
            });
        }

        function createExplosionEffect(point, explosionRadius) {
            const particleCount = Math.floor(explosionRadius / 2); // More particles with higher power
            const gameContainer = document.getElementById('game-container');
            const gameContainerRect = gameContainer.getBoundingClientRect();
            const x = point.x * (gameContainerRect.width / render.canvas.width);
            const y = point.y * (gameContainerRect.height / render.canvas.height);

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';

                // Position particle at explosion point
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;

                // Random velocity and angle
                const angle = Math.random() * 2 * Math.PI;
                const speed = Math.random() * explosionRadius / 2 + explosionRadius / 2; // Speed adjusted based on explosion radius

                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;

                // Set custom properties to control animation
                particle.style.setProperty('--move-x', `${velocityX}px`);
                particle.style.setProperty('--move-y', `${velocityY}px`);
                particle.style.setProperty('--rotation', `${Math.random() * 360}deg`);
                particle.style.setProperty('--scale', `${Math.random() * 0.5 + 0.5}`);

                // Randomize particle color
                const colors = ['#FF4500', '#FFA500', '#FFD700', '#FFFF00', '#808080', '#FF69B4', '#00FFFF', '#ADFF2F'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                particle.style.backgroundColor = color;

                // Append particle to game container
                gameContainer.appendChild(particle);

                // Remove particle after animation
                setTimeout(() => {
                    particle.remove();
                }, 1000); // Duration matches the CSS animation
            }
        }

        function fragmentBody(body) {
            const currentWidth = body.bounds.max.x - body.bounds.min.x;
            const currentHeight = body.bounds.max.y - body.bounds.min.y;

            // Remove the original body
            World.remove(world, body);

            // Calculate the size of the fragments
            const fragmentWidth = currentWidth / 2;
            const fragmentHeight = currentHeight / 2;

            // Remove the block if it's too small to fragment further
            if (fragmentWidth < minBlockSize || fragmentHeight < minBlockSize) {
                // Instead of returning, we remove the body completely
                return;
            }

            // Create three fragments
            const fragments = [];

            for (let i = 0; i < 3; i++) {
                const fragment = Bodies.rectangle(
                    body.position.x + (Math.random() - 0.5) * currentWidth,
                    body.position.y + (Math.random() - 0.5) * currentHeight,
                    fragmentWidth,
                    fragmentHeight,
                    {
                        restitution: body.restitution,
                        friction: body.friction,
                        render: {
                            fillStyle: body.blockColor // Use the parent block's color
                        }
                    }
                );
                fragment.blockColor = body.blockColor; // Ensure fragments carry the blockColor

                // Apply a slight random velocity to the fragments
                Body.setVelocity(fragment, {
                    x: body.velocity.x + (Math.random() - 0.5) * 2,
                    y: body.velocity.y + (Math.random() - 0.5) * 2
                });

                fragments.push(fragment);
            }

            // Add fragments to the world
            World.add(world, fragments);
        }

        function handleCanvasClick(event) {
            // Get mouse position relative to canvas
            const rect = render.canvas.getBoundingClientRect();
            const scaleX = render.canvas.width / rect.width;
            const scaleY = render.canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            const explosionPoint = { x: x, y: y };
            applyExplosion(explosionPoint);
        }

        function removeOffScreenBodies() {
            const bodies = Composite.allBodies(world);

            bodies.forEach(body => {
                if (
                    body.position.y > render.canvas.height + 100 ||
                    body.position.x < -100 ||
                    body.position.x > render.canvas.width + 100
                ) {
                    World.remove(world, body);
                }
            });
        }

        // Function to generate a random color
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            // Re-render the scene
            Render.world(render);
        });

        function resizeCanvas() {
            const gameContainer = document.getElementById('game-container');
            const width = gameContainer.clientWidth;
            const height = window.innerHeight - gameContainer.getBoundingClientRect().top - 150; // Adjust as needed

            render.canvas.width = width;
            render.canvas.height = height;

            render.options.width = width;
            render.options.height = height;
        }

        // Event listeners for buttons
        playButton.addEventListener('click', function() {
            if (isPlaying) {
                pauseGame();
            } else {
                startGame();
            }
        });

        resetButton.addEventListener('click', function() {
            resetGame();
        });

        // Initialize the game for the first time
        initGame();
        pauseGame(); // Start in paused state

        // Listen for mouse clicks on the canvas to apply explosions
        render.canvas.addEventListener('mousedown', handleCanvasClick);
    </script>
</body>
</html>
